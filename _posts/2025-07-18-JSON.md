---
layout: single
title: "C# JSON序列化与反序列化基础"
date: 2025-06-24 10:00:00 +0800
author: default
categories: [教程, Jekyll]
tags: [目录, markdown, 博客]
toc: true          # ✅ 开启目录
toc_sticky: true   # ✅ 目录固定在侧边栏
toc_label: "目录"  # ✅ 可自定义标题，如 Table of Contents
toc_icon: "list-ul"
comments: true     # ✅ 如果你开启了评论系统
read_time: true    #显示时间
header:
  teaser: /assets/img/logo.png    
---

>  **这篇文章我们来讲C#的JSON序列化和反序列化**

---

> **前言:如果对里面的概念有什么不懂的话，可以看我结尾的QA问答，如果还是不懂，欢迎在文章底下留言**

> **另外，以下的操作均使用NewtonSoft.Json这个包,如果不知道怎么安装这个包可以去看我写的关于NuGet包的教程**

# 一，什么是JSON

Json在C#中就像一种万能翻译格式

>**有两种格式，一种格式为单行格式，另外一种格式为多行格式**

**单行格式**
格式为
{"字段" : "值","字段","值"}

如我们的用户名和密码那他的格式就是
{"user_no" : "ADMIN","user_pwd" : "123"}

**多行格式**
格式为
[{"字段" : "值","字段","值"},{"字段" : "值","字段","值"}]

用中括号包裹，中间使用逗号隔开两个行

目前大部分网页都是使用`JSON`传值，少部分使用XML传值

# 二，为什么要进行序列化?

在我们一般写的程序中，我们从中转换都是`Object`类型的对象

比如单行的对象有自定义的实体类，``DataRow``
多行对象有`List<>`,`DataTable`

这些我们接下来都会讲

我们平常使用这些对象是没有问题的，但是呢，如果我们涉及到数据交互(如网站前后端)，程序无法读取我们的对象的，这个时候我们就需要将他转换成JSON,这个过程就叫序列化

同理，如果我们接收并应用这个数据的话，我们照样得给我们接收到的JSON转换成对象，这个过程就叫反序列化

通俗解释就是

>序列化的过程就是商家给你发货的时候要把东西给你装箱贴上快递单,才能交给快递员(系统)处理

>反序列化的过程就是你收到快递了你要拆箱子然后按说明书才能把你接收到的东西组装成你要的东西(对象)

# 三，常见对象说明与序列化和反序列化

在C#中,有很多种对象，我这里只讲几个主流的单行和多行的对象

## 1.0单行数据

### 1.1键值对Dictionary<> (泛型字典)

由微软.NET团队在2005年引入

引入版本 .NET Framework 2.0

**核心作用**

通过哈希算法实现快速键值对映射

**用法**

{% highlight csharp %}
{
    //这个键值对中的string,object是一个泛型类型，我们这里给他指定了两个类型
    //一个是string字符串类型，一个是object对象类型
    //给这个data赋值一个新的Dictionary<>键值对
    Dictionary<string, object> data = new Dictionary<string, object>();
    data["user_no"] = "ADMIN";
    data["user_pwd"] = "123";
    //添加他的属性值，比如我们这里添加ADMIN,123,在实际应用中,可以添加成我们输入的值
    //通常应用中，我们需要给他转换成字符串

    //把Object的JSON对象转换成字符串
    string strJson = JsonConvert.SerializeObject(data);
    //JsonConvert.SerializeObject(data);转化语句
    //给这个strJson赋值一个转化的语句,将object对象转换为字符串
}
{% endhighlight %}

在上面的代码可以看到，我们先使用了这个`Dictionary<>`标注的两个数据类型(`string`,`object`),这样做的目的是为了我们之后能支持更多形式的数据,比如`DataTime`,`int`,如果你想的话也可以`Dictionary<string,string>`

>**注意，这个类型必须要两个参数，你不能说就写一个`Dictionary<string>`,如果你想写单个参数你也必须遵循他的写法规范，比如说我只写一个字符串类型，那也得`Dictionary<string,string>`**

`Dictionary<string, object> data = new Dictionary<string, object>();`

这段代码首先是给data这个参数指定类型了，然后实例化了这个Dictionary并给data赋值,除了这样写,我们还可以直接这样写

`var data = new Dictionary<string,object>`

系统会自动推断这是一个什么类型的类,但是我目前不推荐这种写法

因为你写的时候没问题，程序能跑得起来，如果别人看就不一定能看得懂你这代码到底是一个什么类型了，所以我这里列出仅供参考

接下来我们给他声明完毕之后我们就可以开始传值了，可以看到上面的代码是这样的

{% highlight csharp %}

data["user_no"] = "ADMIN";
data["user_pwd"] = "123";

{% endhighlight %}

这里我们就开始根据我们刚刚定义的这个类开始声明字段，一共声明了两个

这里是直接给他的值写死了，在现实应用中，我们大部分都是来获取我们Text控件的值，进行一个双向获取

{% highlight csharp %}

var user_no = this.txtUserNo.Text.Trim()
var user_pwd = this.txtUserPwd.Text.Trim()

data["user_no"] = user_no;
data["user_pwd"] = user_pwd;

{% endhighlight %}

这里我举一个例子，在现实生活中很多都是这样来动态获取他的值

最后我们已经获取到值了,但是呢，我们现在这个值还是以对象的形式存在，所以我们现在要进行序列化

` string strJson = JsonConvert.SerializeObject(data);`

我们明确指定这是字符串的格式，然后使用这个类获取我们在上面定义过类的名称`data`进行一个转换，到这里我们就完成了序列化了

### 1.2.匿名类

由微软.NET团队在2007年引入

引入版本 .NET Framework 3.5

**核心作用**

搭配`LINQ`进行数据投影，临时数据构造

**用法**

{% highlight csharp %}
{
    object data = new
    {
        user_no = "ADMIN",
        user_pwd = "123"
    };
    string strJson = JsonConvert.SerializeObject(data);
}
{% endhighlight %}

可以看到，匿名类的代码是很短的，对比我们上面的`Dictionary<>`,这就他的优点之一，代码量少

但是缺点也非常显而易见，他是无法更改的，是一次性的，我不能说假如我哪一天要给他加个字段给他写成这样行不行

{% highlight csharp %}
{
    object data = new
    {
        user_no = "ADMIN",
        user_pwd = "123"
    };
    string strJson = JsonConvert.SerializeObject(data);

    data.user_name = "123"
}
{% endhighlight %}

这样写是不行的，会发生报错，匿名类在赋值初始化完毕之后就无法修改了，他是一次性的，只能`get`(查询)不能`set`修改的

下面这段我就不赘述了，上面已经说过了，是序列化的语句

### 1.3Dynamic动态类

由微软.NET团队在2010年四月随着Visual Studio2010引入

引入版本 .NET Framework 4.0

实际上他也是Dictionary<>的一种，是一种特殊的封装

**核心作用**

让你可以绕过编译器的检查，标注字段的时候不需要事先声明

**用法**

这里我们使用Dynamic + ExpandoObject

{% highlight csharp %}
  {
    dynamic data = new ExpandoObject();

    data.user_no = "ADMIN";
    data.user_pwd = "123";

    string strJson = JsonConvert.SerializeObject(data);
  }
{% endhighlight %}

dynamic类型是给编译器声明我这个类是dynamic类型的，让他不要检查我这个字段有没有声明了

所以他是不能new的，如果我们想给他new 就需要用到他这下面的类ExpandoObject

>**为什么dynamic不能new 因为new关键字是明确知道这个是一个什么类型的，但是dynamic不算一个类型，他只是告诉编译器我现在这个不需要检查字段了**

这个类的好处就是编译器不会检查我这个字段是否声明，不需要写方法的时候还得进行声明再转换,如果在编译的时候发现这个字段不存在，也不会报错并崩溃，只会返回一个null

但是他也是有缺点的，缺点就是因为我们没有声明，所以IDE是检测不到我们字段的，这就会导致我们写的时候没有智能提示，自己写的话容易写错，而且因为他的优点检测不存在字段的时候不会报错,哪怕我写错了，这也会导致如果我因为这个写错了程序逻辑跑不通调试的时候不容易找出来

>**如果说 dynamic 是剧场的灯光师，ExpandoObject 就是演员本身——它真正扮演了一个“可变对象”的角色，虽然底下藏着一张 Dictionary 的脸。**

### 1.4自定义类

>**这个类是我日常使用最多的一个类**

由.NET团队在发明C#的时候就有了 2002

引入版本 .NET Framework 1.0

**核心作用**

使用强类型的自定义业务模型，使得代码更安全，更清晰

**用法**

首先我们先来开始定义我们的实体类，也可以叫模型

这里有两种写法，我先写第一种

{% highlight csharp %}
public class UserInfo
{
    //注意，私有变量和属性不能重名，一般命名的规范是私有变量在属性的前面加一个下划线
    //这样可以区分开来，避免混淆,另外可以明确这两个属性的对应关系
    private string _user_no = "";
    public string user_no
    {
        get { return _user_no; }
        set { _user_no = value; }
    }

    //这个实体类是全世界的标准写法，VS2022会自动生成这个实体类的代码
    private string _user_pwd = "";
    public string user_pwd
    {
        get { return _user_pwd; }
        set { _user_pwd = value; }
    }
}

{% endhighlight %}

这个是第一种写法，写了两个私有变量和公有变量，映射数据库的字段

这个优点就是我们可以自己在这里面写判断逻辑
缺点就是代码量比简写多

{% highlight csharp %}
public class UserInfo
{
    public string user_no { get; set; } = "";

    public string user_pwd { get; set;} = "";
}

{% endhighlight %}

这个是第二种写法，是简写写法，实际上编译器也会生成私有变量
优点是代码量少，缺点就是没法自己在这里面写逻辑处理

**那我们怎么引用他呢?**

{% highlight csharp %}
public class UserInfo
{
     Userinfo userInfo = new UserInfo();
     userInfo.user_no = "ADMIN";
     userInfo.user_pwd = "123";

     string strJson = JsonConvert.SerializeObject(userInfo);
}

{% endhighlight %}

在这里，我们先声明了我们的自定义实体类，然后接着我们给userinfo赋值
赋值两个值，这样我们就成功的引用完成了


## 2.0多行数据

> **多行数据有两种，我们接下来慢慢讲**

### 2.1List集合

由微软.NET团队在2005年发布

发布版本 .NET Framework 2.0

**核心作用**


